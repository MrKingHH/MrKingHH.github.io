<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[用户与组管理]]></title>
    <url>%2F2018%2F07%2F06%2F%E7%94%A8%E6%88%B7%E4%B8%8E%E7%BB%84%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[用户与组管理Linux系统将账户分为以下3种类型。 超级用户 root 系统用户 这是系统本身或应用程序使用的专门账户。 普通用户 这是供实际用户使用的普通用户账户 与用户账户类似，组账户分为以下3种类型。 超级组 系统组 自定义组 用户与组配置文件：在linux系统中，用户账户、用户密码、组信息均存放在不同配置文件中。 用户配置文件(1)用户账户配置文件：/etc/passwd该文件中一行定义一个用户账户，每行均由7个字段构成，各字段之间用冒号分隔。基本格式如下：账户名:密码:UID:GID:注释:主目录:Shell如果要禁止用户账户登录Linux，只需将Shell字段设置成/sbin/nologin即可。如果要临时禁用某个账户，可以在passwd中该账户记录行前加上星号(*)。密码字段为x，因为该文件不存放账户密码。(2)用户密码配置文件/etc/shadow为了安全起见，用户真实的密码采用MD5算法加密后，保存在该文件中。改文件需要root权限才能修改，shadow组成员可以读取，其他用户禁止访问。可以使用sudo vi /etc/shadow直接查看。shadow文件也是每行定义一个账户信息，每行由9个字段构成，各字段值之间用冒号分隔，基本格式如下：账户名:密码：最近一次修改:最短有效期:最长有效期:过期前警告q期:禁用:保留用于未来扩展第二个字段值如果为空，表示没有密码；如果为!!表示密码被禁用。 组配置文件(1)组账户配置文件/etc/group每个组账户在group文件中占用一行，并且用冒号分为4个字段，格式如下：组名:密码:GID:组成员列表只有用户的次要组才会将其成员列出。(2)组账户密码配置文件/etc/gshadow每个组账户在gshdow文件中占用一行，并且用冒号分为4个字段，格式如下：组名:加密后的组密码:组管理员:组成员列表 使用命令行工具管理用户和组： 查看用户账户如果只查看全部用户名列表，可以考虑用文本分析工具awk。例如：awk -F’:’ ‘{print $1}’ /etc/passwd 添加用户账户基本用法如下：useradd [选项] &lt;用户名&gt;该命令选项较多。例如-d用于指定用户主目录；-g用于指定该用户所属主要组；-G用于指定次要组等。如果不指定任何参数，则默认创建用户。推荐使用adduser和deluser。]]></content>
      <categories>
        <category>linux操作系统</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件与目录管理]]></title>
    <url>%2F2018%2F07%2F06%2F%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[Linux文件用用户目录管理Linux操作系统使用单一的目录树结构，整个系统只有一个根目录。Linux目录配置标准-FHS文件系统层次标准(Filesystem Hierarchy Standard)，简称FHS。 Linux文件类型 普通文件 目录文件 设备文件 字符设备和块设备。 链接文件 符号链接和硬链接。使用ls -l命令以长格式列目录时，每一行第一个字符代表文件类型。其中-表示普通文件，d表示目录文件， c表示字符设备文件， b表示块设备文件， l表示符号链接文件。使用命令行进行目录操作 创建目录mkdir [-p] 目录名，-p表示要建立的父目录尚未建立，同时创建父目录。 删除目录rmdir [-p] 目录名，选项-p表示递归删除目录，当子目录被删除后父目录为空时，也一并删除。如果非空，则保留下来。 改变工作目录cd [目录名] change directory，不带任何参数时，进入用户主目录。pwd print working directory。 显示目录内容ls [选项] [目录或文件]其选项和含义如下。-a: 显示所有文件，包含隐含文件。-c: 按文件修改时间排序。-i: 在输出文件的第1列显示文件的索引结点号。-l: 以长格式显示文件的详细信息。-r: 按逆序显示ls命令的输出结果。-R: 递归的显示指定目录的各个子目录中的文件。-h: 显示结果有利于人看。使用命令行进行文件操作 文件内容显示1.1 cat [选项] [文件名1] [文件名2]其选项和含义如下。-n或-number:有1开始对所有输出的行数编号。-b或--number-nonblank:和-n相似，只不过对于空白行不编号。-s或--squeeze-blank:当遇到有连续两行以上的空白行，就代换为一行的空白行。该命令有两项功能。第一项是来显示文件的内容。二是用来连接两个或多个文件如cat f1 f2 &gt; f3，将文件f1和f2问内容合并起来，然后通过输出重定向符&gt;将他们的内容存入文件f3中。1.2 more [选项] [文件名]如果文件太长，用cat命令只能看到最后一页，而用more命令时可以逐页显示。其选项和含义如下。-&lt;数字&gt;：指定每屏显示的行数。-d：显示“[press space to continue,’q’ to quit.]”和“[Press ‘h’ for instructions]”。-c：每次显示之前清屏。-s：将多个空行压缩成一行显示。-u：禁止下划线。+&lt;数字&gt;：从指定数字的行开始显示。按Space键：显示文本的下一屏内容。按Enier键：只显示文本的下一行内容。按斜线符|：接着输入一个模式，可以在文本中寻找下一个相匹配的模式。按H键：显示帮助屏，该屏上有相关的帮助信息。按B键：显示上一屏内容。按Q键：退出rnore命令。1.3 less [选项] [文件名]less命令的作用与more十分相似，都可以用来浏览文字档案的内容，不同的是less命令允许用户向前或向后浏览文件，而more命令只能向前浏览。用less命令显示文件时，用PageUp键向上翻页，用PageDown键向下翻页。要退出less程序，应按Q键。其选项和含义如下。-e：文件内容显示完毕后，自动退出；-f：强制显示文件；-g：不加亮显示搜索到的所有关键词，仅显示当前显示的关键字，以提高显示速度；-l：搜索时忽略大小写的差异；-N：每一行行首显示行号；-s：将连续多个空行压缩成一行显示；-S：在单行显示较长的内容，而不换行显示；-x &lt;数字&gt;：将TAB字符显示为指定个数的空格字符。1.4 head [选项] [文件名]head命令用于显示文件的开头的内容。在默认情况下，head命令显示文件的头10行内容。其选项和含义如下。-n &lt;数字&gt;：指定显示头部内容的行数；-c &lt;字符数&gt;：指定显示头部内容的字符数；-v：总是显示文件名的头信息；-q：不显示文件名的头信息。例子：head -n -5 log.txt 输出文件除了最后n行的全部内容1.5 tail [选项] [文件名]tail命令用于输入文件中的尾部内容。tail命令默认在屏幕上显示指定文件的末尾10行。如果给定的文件不止一个，则在显示的每个文件前面加一个文件名标题。如果没有指定文件或者文件名为“-”，则读取标准输入。其选项和含义如下。-f:该参数用于监视File文件增长。-c Number: 从 Number 字节位置读取指定文件-n Number: 从 Number 行位置读取指定文件。-m Number: 从 Number 多字节字符位置读取指定文件，比方你的文件假设包括中文字，假设指定-c参数，可能导致截断，但使用-m则会避免该问题。-b Number: 从 Number 表示的512字节块位置读取指定文件。-k Number: 从 Number 表示的1KB块位置读取指定文件。-r: 逆序显示 文件内容查找grep [选项]... 模式 [文件名]...可以将此处的模式看做要搜索的一些关键词，查看指定的文件里是否包含这些关键词。如果没有指定文件，就从标准输入中读取。其选项和含义如下。-i：表示忽略大小写。-x：强制整行匹配。-w：强制关键字完全匹配。-e：用于定义正则表达式。-r：在指定目录中递归搜索。-H：为每一匹配项打印文件名。-m：定义匹配多少次后停止搜索。例子：grep -i &#39;home&#39; /etc/passwd 文件查找3.1 find [路径] [匹配表达式]例如：查找当前目录下文件名后缀为txt的文件可以执行以下命令，并且打印到屏幕。find . -name &quot;*.txt&quot; -printfind使用动作-exec可以对查到的文件调用外部命令进行处理，此处语法比较特殊，外部命令之后要以{} \;结尾。例子：find /etc -name &quot;passwd*&quot; -exec grep &quot;wang&quot; {} \;表示找到以passwd开头文件里的字符串wang。3.2 locate [选项]... [模式]...locate用于查找文件，它比find命令搜索速度快，但需要一个数据库，默认数据库在/var/lib/mlocate/mlocate.db。其选项和含义如下。-d:指定locate使用的数据库，取代默认数据库。-c:表示只列出查到的条目数量。-A:表示列出匹配的所有条目。-w:表示匹配整个路径。 文件内容统计wc [选项] 文件名列表wc命令用于统计出文件的字节数、字数、行数，并输出结果。wc命令的输出顺序和数目不受选项和数目的影响，输出格式如下：行数 字数 字节数 文件名其选项和含义如下。-c:表示统计字节数。-l:表示统计行数。-w:表示统计字数。 文件内容比较5.1 comm [-123] 文件1 文件2选项-1表示不显示仅在文件1中存在的行，选项-2表示不显示仅在文件2中存在的行，选项-3表示不显示在comm命令中的第1列、第2列和第3列。5.2 diff [选项] 文件1 文件2diff命令逐行比较两个文件，列出他们的不同之处。如果完全一样，则没有任何输出。 文件(目录)复制、删除和移动6.1 cp [选项] 源文件或目录 目标文件或目录例子：将文件file复制到目录/usr/men/tmp下，并改名为file1。cp file /usr/men/tmp/file1将目录/usr/men下的所有文件及其子目录复制到目录/usr/zh中。cp -r /usr/men /usr/zh交互式地将目录/usr/men中的以m打头的所有.c文件复制到目录/usr/zh中。cp -i /usr/men m*.c /usr/zh我们在Linux下使用cp命令复制文件时候，有时候会需要覆盖一些同名文件，覆盖文件的时候都会有提示：需要不停的按Y来确定执行覆盖。文件数量不多还好，但是要是几百个估计按Y都要吐血了，于是折腾来半天总结了一个方法：cp aaa/* /bbb复制目录aaa下所有到/bbb目录下，这时如果/bbb目录下有和aaa同名的文件，需要按Y来确认并且会略过aaa目录下的子目录。cp -r aaa/* /bbb这次依然需要按Y来确认操作，但是没有忽略子目录。cp -r -a aaa/* /bbb依然需要按Y来确认操作，并且把aaa目录以及子目录和文件属性也传递到了/bbb。\cp -r -a aaa/* /bbb成功，没有提示按Y、传递了目录属性、没有略过目录。6.2 rm [选项] 文件列表其选项和含义如下。-d：直接把欲删除的目录的硬连接数据删除成0，删除该目录。-f：强制删除文件或目录。-i：删除已有文件或目录之前先询问用户。-r或-R：递归处理，将指定目录下的所有文件与子目录一并处理。--preserve-root：不对根目录进行递归操作。-v：显示指令的详细执行过程。6.3 mv [选项] 源文件或目录 目标文件或目录 文件压缩和解压缩7.1 gzip [选项] 压缩文件名/解压文件名可以压缩和解压缩。被压缩的文件扩展名为.gz7.2 unzip [选项] 压缩文件名用于对winzip格式的压缩文件进行解压。7.3 tar [选项] 文件或者目录名用于对文件和目录进行打包。 管理文件和目录权限 文件访问者身份与文件访问权限1.1 文件访问者身份所有者、所属的组、其他人。1.2 文件访问权限读、写、执行。1.3 查看文件属性-rw-r--r-- 1 jinyuxin jinyuxin 8980 7月 5 20:38 examples.desktop其中文件信息公有7个字段，第一个字段表示文件类型与权限。其中第一个字符表示文件类型，-表示文件，l表示链接文件，b表示块设备，c表示字符设备。接下来的字符以3个位一组，分别表示文件所有者、所属组、其他用户的权限，每一种用户的3种文件权限依次为r、w、x，表示读、写、执行，如果某种权限没有，则用-表示。第二个字段表示文件的链接数目。第三个字段拜师这个文件的所有者，第四个字段表示所属组。后面3个字段分别表示文件大小、修改日期和文件名称。 变更文件访问者身份2.1 变更所有者sudo chown [选项] [新所有者] 文件列表2.2 变更所属组chgrp [选项] [新的所属组] 文件列表 设置文件访问权限3.1 文件权限用字符表示chmod [选项]... 模式[,模式]... 文件名...所有者、所属组、和其他用户分别用字符u、g、o表示，全部用户则用a表示。例子：chmod g+w,o+r /home/jinyuxin/myfilechmod go-r /home/jinyuxin/myfilechmod a=rx /home/jinyuxin/myfile3.2 文件权限用数字表示将读、写、执行分别用数字4、2、1表示，没有任何权限则用0表示。chmod 644 file等同于chmod u=rw,go=r-- file]]></content>
      <categories>
        <category>linux操作系统</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件包管理]]></title>
    <url>%2F2018%2F07%2F06%2F%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[软件包管理Linux软件包管理发展过程 从源代码安装软件早期的Linux系统中主要使用源代码包发布软件，用户往往要直接将源代码编译成二进制文件，并对系统进行相关配置，有时甚至还要修改源代码。源代码编译安装比较耗时，对普通用户来说难度太大，为此推出了软件包管理概念。 使用软件包安装软件软件包将应用程序的二进制文件、配置文档和帮助文档等合并打包在一个文件夹中，用户只需使用相应的软件包管理工具来执行软件的安装、卸载、升级、查询等操作。目前主流的软件包格式有两种：RPM和Deb。RPM是RedHat Package Manager(软件包管理器)的缩写，是由RedHat公司提出的一种软件包管理标准，文件后缀名为.rpm。可以使用rpm工具拉埃管理RPM包。Deb是Debian Package的缩写，是Debian和Ubuntu系列发行版本上使用的软件包格式，后缀名为.deb，需要使用dpkg命令进行管理。dpkg是Debian Packager的简写，用于安装、更新、卸载Deb软件包，以及提供Deb软件包相关的信息。当然，RPM或Deb软件包安装也要考虑依赖性问题，只有应用程序所依赖的库和支持文件都正确安装以后。才能完成软件的安装。现在的软件依赖性越来越强，单纯使用这种软件包安装效率很低，难度也不小，为此提出了高级软件包管理工具。 高级软件包管理工具高级软件包管理工具通过Internet主动获取软件包，自动检查和修复软件包之间的依赖关系，实现软件的自动安装和更新升级，大大简化了Linux系统上安装、管理软件的过程。目前主要的高级软件包管理工具有Yum和APT两种。Yum(Yellow dog Updater,Modified)是一个机遇RPM包的软件包管理器，能够从指定服务器下载RPM包并且完成安装，可以处理依赖性关系。Red Hat Enterprise Linux、CentOs、Fedora等Linux发行版采用Yum。APT(Advanced Packing Tools)是Debian及其派生发行版(如 Ubuntu)的软件包管理器。APT可以自动下载、配置、安装二进制或者源代码格式的软件包。APT最早被设计成dpkg工具的前端，用来处理Deb格式的软件包。现在经过APT-PRM组织修改，RPM版本的APT已经可以安装在使用RPM的Linux发行版上。 APT命令行工具的使用 使用apt-cache命令查询软件包使用apt-cache pkgnames列出当前所有可用的软件包。使用apt-cache search httpd查找指定名字的软件。使用apt-cache show 软件包名可以查看指定名称的软件包的详细信息。使用apt-cache depends 软件包名可以查看软件包所依赖的软件包。使用apt-cache rdepends 软件包名可以查考被哪些软件包所依赖。使用apt-cache showpkg 软件包名查看软件包的依赖关系信息。使用apt-cache policy 软件包名显示软件包的安装状态和版本信息。 使用apt-get命令操作软件包sudo apt-get [选项] 子命令apt-get update 获取最新的软件包列表，同步/etc/apt/sources.list 和 /etc/apt/sources.list.d中列出的源的索引。以确保用户能够获取最新的软件包。apt-get upgrade 更新当前系统所有已安装的软件包，并同时更新这些软件包所依赖的软件包。执行该命令之前，一定要先执行apt-get update命令，以确保软件包信息是最新的。apt-get install 下载、安装软件包并自动解决依赖关系。apt-get remove 卸载指定的软件包。apt-get autoremove 自动卸载所有未使用的软件包。apt-get purge 卸载指定的软件包及其配置文件。apt-get source 下载软件包的源码。apt-get clean 清理已下载的软件包，实际上是清除/var/cache/apt/archives目录中的软件包，不会影响软件的正常使用。apt-get autoclean 删除已卸载的软件的软件包备份 安装软件包建议用户每次安装和更新软件包之前先执行apt-get update更新系统中的软件包信息。]]></content>
      <categories>
        <category>linux操作系统</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux命令行详解]]></title>
    <url>%2F2018%2F07%2F06%2FLinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[命令行详解命令行有两种方式，一种是在桌面环境中使用仿真终端。另一种是进入文本模式后登录到终端。当前用户名@当前主机名:当前目录 命令提示符普通用户登录时 命令提示符为$ root用户登陆后 命令提示符为#shutdown 关机reboot 重启 shutdown -rshutdown -h now 立即关机shutdown +10 “System will shutdown after 10 minutes”halt -p 关闭系统且切断电源 将内存中的缓存数据都写到磁盘上shell有多种不同的版本，按照来源可以分为两大类型。一类是由贝尔实验室开发的，以Bourne Shell(sh)为代表，此类兼容的有Bourne-Again Shell(bash)、Korn Shell(ksh)、Z Shell(zsh)。另一类是由加州大学伯克利分校开发的，以C Shell(csh)为代表，与之兼容的由TENEX C shell(tcsh)。Ubuntu默认使用的Shell程序是bash。利用echo $SHELL查看当前使用的shell类型。bash是sh的增强版本，完全兼容sh。 环境变量：常用的环境变量有PATH HOME LOGNAME HOSTNAME PS1 SHELL 命令语法格式：命令 选项 参数选项。选项是包含一个或多个字母的代码，前面有一个‘-’连字符。使用一个命令的多个选项时，可以简化输入。例如，将命令ls -l -a 简写为ls -la。不带参数的ls只能列出当前目录下的文件和目录。而使用参数可列出指定目录或文件中的文件和目录。 命令行基本用法：用户执行过的命令保存在一个命令缓存区中，成为命令历史表。默认情况下，bash可以存储1000个历史命令。用history来查看历史命令。利用!编号可以执行该编号的历史命令。命令行续行。利用反斜杠 \ 进入下一行。对于linux命令，可以使用 –help来查看命令。命令行输入与输出：Shell程序通常自动打开3个标准文档：标准输入文档，标准输出文档和标准错误输出文档。多数情况下，linux使用标准输入输出作为命令的输入输出，但有时可能要改变标准输入输出，这就涉及重定向及管道。 输入重定向主要用于改变命令输入源。基本用法：命令 &lt; 文件名例如，wc命令用于统计指定文件包含的行数、字数和字符数，直接执行不带参数的wc命令，将等待用户输入内容之后，按ctrl+d结束输入后才对输入内容进行统计。而执行下列命令通过文件为wc命令提供统计源。wc &lt; /etcprotocols 输出重定向主要用于改变命令的输出，让标准输出不要显示在屏幕上。而是写入到指定文件中。基本用法是：命令 &gt; 文件名如果要写入已有文件，则只能用追加的功能。将&gt;改为&gt;&gt;即可。以上是对标准输出来讲的，至于标准错误输出重定向，只需将&gt;换成2&gt;,将&gt;&gt;换成2&gt;&gt;。将标准输出和标准错误输出重定向到同一文件，则使用符号&amp;&gt;。 管道管道用于将一个命令的输出作为另一个命令的输入，使用符号&quot;|&quot;来连接命令。可以将多个命令依次连接起来，前一个命令的输出作为另一个命令的输入。基本用法是：命令1 | 命令2 …… | 命令n在linux命令行中，管道操作非常实用。例如，以下命令将ls命令的输出结果交给grep命令进行搜索。ls | grep &quot;ab&quot;。在执行输出结果内容较多的命令时可以通过管道实用more命令进行分页显示。 命令替换命令替换与管道命令有些相似，不同的是命令替换是将一个命令的输出作为另一个命令的参数，常用命令格式如下：命令1 命令2其中命令2的输出作为命令1的参数 使用Vim编辑器实现复制粘贴: 使用vim 文件名命令进入该文件 将光标移动到要复制的文本的地方,按V键进入可视模式 将光标移至末尾，按y复制。此时自动退出可视模式。 移动光标到要粘贴的地方，按p粘贴。 使用vim编辑器查找字符串： /关键字 按回车键向下查找字符串。 ?关键字 按回车键向上查找字符串。 在末行模式下: 列出行号：输入set nu 调到某一行：输入数字即可]]></content>
      <categories>
        <category>linux操作系统</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scrapy爬取网易NBA滚动新闻遇到的问题]]></title>
    <url>%2F2018%2F06%2F29%2FScrapy%E7%88%AC%E5%8F%96%E7%BD%91%E6%98%93NBA%E6%BB%9A%E5%8A%A8%E6%96%B0%E9%97%BB%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[博文前言 最近跟同学在做一个NBA新闻整合的项目，项目的网址是：https://github.com/ACLoong/nba-tall. 此前写了一个爬取虎扑NBA新闻的爬虫，当时解决二次爬取网易内的URL的方式是：利用BeautifulSoup库+requests库，对解析出来的url进行再次爬取，因为当时解析二次url内容的时候比较容易，所以没有想到用scrapy的“自带”的方法。直到今天遇到爬取二次url页面内容的时候，遇到了比较大的困难—没有办法拼接所有的p标签文本为一整段新闻主体。逼着我用scrapy的方法来解析网页。 进入正题 网易NBA滚动新闻的首页网址是：http://sports.163.com/special/nbagd2016/下一页网址是：http://sports.163.com/special/nbagd2016_02/下下一页的网址是：http://sports.163.com/special/nbagd2016_03/下下下一页以此类推。我这次只爬了四个页面。这次爬虫需求如下: 爬取新闻标题，时间，url连接。 顺着爬取的url接着爬取该url所在页面的新闻内容。 这次爬取时遇到的问题如下: BeautifulSoup库+requests库无法解析出页面的主体内容并完成拼接。 不知道怎么用修改scrapy的wangyinews.py文件以使得其可以完成二次url的内容解析。 不知道怎么将wangyinews.py和hupunews.py爬取的信息输出到不同的json文件。 不明白为什么查看源代码时使用查找操作找到的p标签个数和用BeautifulSoup库的find_all(‘p’)的个数不一样。 解决问题1、2办法如下: 在wangyinews.py文件中增加一个解析二次url的函数parseContent(self,response)。 获取新闻标题，新闻url链接的实现放在parse函数里，然后对每一个已经获得标题和url链接的item，使用生成器，包装一个Request请求，包装如下：Request(item[&#39;newsUrl&#39;],meta={&#39;item&#39;:item},callback=self.parseContent)。其中meta表示提交给该url的信息，callback表示将response信息回调给parseContent()函数。 再在parseContent()函数中，对新闻时间和新闻内容做解析。 wangyuinews.py具体代码如下:1234567891011121314151617181920212223242526272829303132333435363738394041424344# -*- coding: utf-8 -*-import scrapyimport requestsfrom nbanews.items import WangyinewsItemfrom scrapy.http import Requestclass WangyinewsSpider(scrapy.Spider): def parseContent(self, response): #用来拼接新闻内容的空字符串 newsContent = &apos;&apos; #从parse函数传过来的meta数据 item = response.meta[&apos;item&apos;] #获取新闻的时间，并做了进一步的优化处理 newsTime = response.xpath(&apos;//div[@class=&quot;post_time_source&quot;]/text()&apos;).extract()[0].replace(&apos; &apos;,&apos;&apos;).replace(&apos;\n&apos;,&apos;&apos;).replace(&apos;来源:&apos;,&apos;&apos;) #获取新闻内容 subSelector = response.xpath(&apos;//div[@class=&quot;post_text&quot;]/p//text()&apos;) for sub in subSelector: newsContent += sub.extract() item[&apos;newsContent&apos;] = newsContent.replace(&apos;\n&apos;,&apos;&apos;) item[&apos;newsTime&apos;] = newsTime #返回新闻，每次返回一个，就释放内存，速度快，而不是一次性返回列表 yield item def parse(self, response): items = [] #找到新闻列表 sub = response.xpath(&apos;//div[@class=&quot;news_item&quot;]&apos;) #获取新闻列表长度 length = len(sub) #解析出所有新闻的标题和链接 for i in range(0,length): item = WangyinewsItem() #解析新闻标题 item[&apos;newsTitle&apos;] = sub[i].xpath(&apos;./h3/a/text()&apos;).extract()[0] #解析新闻url newsUrl = sub[i].xpath(&apos;./h3/a/@href&apos;).extract()[0] item[&apos;newsUrl&apos;] = newsUrl item[&apos;newsSrc&apos;] = &apos;2&apos; #把该新闻放到新闻列表里 items.append(item) #对每一个列表里的每一条新闻，根据其url调用crapy.http.Request()函数,并将item传给callback指定的parseContent函数 for item in items: yield Request(item[&apos;newsUrl&apos;], meta=&#123;&apos;item&apos;:item&#125;, callback=self.parseContent) 解决问题3办法如下: 在items.py文件里增加两个items类，一个是HupunewsItem类，一个是WangyinewsItem类。 在怎么处理数据的pipelines2json.py文件里增加一个isinstance的判断。判断当前item是什么类。 items.py具体代码如下:12345678910111213141516171819202122232425262728import scrapyclass HupunewsItem(scrapy.Item): # define the fields for your item here like: # name = scrapy.Field() #新闻标题 newsTitle = scrapy.Field() #新闻时间 newsTime = scrapy.Field() #新闻url newsUrl = scrapy.Field() #新闻内容 newsContent = scrapy.Field() #新闻来源平台 newsSrc = scrapy.Field()class WangyinewsItem(scrapy.Item): # define the fields for your item here like: # name = scrapy.Field() #新闻标题 newsTitle = scrapy.Field() #新闻时间 newsTime = scrapy.Field() #新闻url newsUrl = scrapy.Field() #新闻内容 newsContent = scrapy.Field() #新闻来源平台 newsSrc = scrapy.Field() pipelines2json.py具体代码如下:123456789101112131415161718192021222324import timeimport jsonimport codecsfrom nbanews.items import HupunewsItemfrom nbanews.items import WangyinewsItemclass NbanewsPipeline(object): #怎么处理提取到的新闻 def process_item(self, item, spider): today = time.strftime(&apos;%Y-%m-%d-%H&apos;,time.localtime())#返回指定格式的时间字符串，年-月-日，用来做文件名称 if isinstance(item, HupunewsItem): fileName = today + &apos;hupu.json&apos; #先将items里的文件写入到txt文本里,已追加的方式写,一行为一个item，写完之后换行，item的内部元素之间以制表符\t隔开 with codecs.open(fileName,&apos;a&apos;,encoding = &apos;utf8&apos;) as f: line = json.dumps(dict(item),ensure_ascii=False)+&apos;\n&apos; f.write(line) time.sleep(3) elif isinstance(item, WangyinewsItem): fileName = today + &apos;wangyi.json&apos; #先将items里的文件写入到txt文本里,已追加的方式写,一行为一个item，写完之后换行，item的内部元素之间以制表符\t隔开 with codecs.open(fileName,&apos;a&apos;,encoding = &apos;utf8&apos;) as f: line = json.dumps(dict(item),ensure_ascii=False)+&apos;\n&apos; f.write(line) time.sleep(3) return item 至此，问题解决。]]></content>
      <categories>
        <category>bug汇总</category>
      </categories>
      <tags>
        <tag>scrapy</tag>
        <tag>网络爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next美化博客遇到的棘手的问题]]></title>
    <url>%2F2018%2F06%2F21%2FNext%E7%BE%8E%E5%8C%96%E5%8D%9A%E5%AE%A2%E9%81%87%E5%88%B0%E7%9A%84%E6%A3%98%E6%89%8B%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[博文前言 从开始创建博客到现在初具规模，满打满算大概花了整整两天的时间，其中还包括昨天在实验室通宵到两点多，然后接着把西班牙的球赛看完了，不得不说西班牙的足球踢得真好啊。这几天中，几乎把所有的精力都放在研究怎么创建博客上面。总结一下我的过程，基本上就是在网上找各种教程，跟着教程一步一步走，但是我发现好多教程是重复的，导致我为了实现某一功能而进行了多处设置，结果导致各种效果重叠显示，适得其反。现将遇到的几个棘手的问题整理如下。 进入正题 图片在本地编辑时可以预览，但是一旦部署到服务器就显示不出来。解决办法：第一步：先将主题配置文件里的post_asset_folder:设置为true。&emsp;&emsp;&emsp;&emsp;&emsp;第二步：然后在博客根目录下，执行命令npm install hexo-asset-image --save,这个插件是用来上传本地图片的。&emsp;&emsp;&emsp;&emsp;&emsp;第三步：等插件安装结束之后，使用hexo n &quot;博客名称&quot;来生成博文时，会发现在source文件夹下有一个与博客名称同名的文件夹，将图片放入该文件夹中即可。引用的路径为博客名称/图片名称。&emsp;&emsp;&emsp;&emsp;&emsp;第四步：利用hexo clean清除public文件夹，再利用hexo g重新生成public文件夹，检查public\2018\06\21\博客名称\index.html文件中的&lt;image&gt;标签的src属性值为/2018/06/21/博客名称/图片名称,而不再是原来的博客名称/图片名称。 分类页面不显示分类标签。解决办法：找了半天才发现是自己分类页面的type: &quot;categories&quot;被我自己写成了tags: &quot;categories&quot;，真的是被自己蠢哭啊。将其改正就能自动显示分类标签了。浪费了好长时间来解决这个bug。 页面内的超链接有的显示为蓝色，有的不显示为蓝色。解决办法：通过查看渲染的代码，是一个CSS的交集选择器，是渲染body里的p标签里的a标签，然后我查看了一下不能渲染的网页源代码，发现不能渲染的超链接不在p标签内，因为我当时直接用的列表，所有直接给我转换成了&lt;ol&gt;。故重新编辑md文档，确保其能被转换成被&lt;p&gt;标签包围的形式。 没有阅读全文。解决办法：在主题配置文件里 设置auto_excerpt: enable:true 版权申明有重复。解决办法：我将自己看的博客中，设置版权的几种方法整理如下：&emsp;&emsp;&emsp;&emsp;&emsp;(1)在文章底部增加自定义版权信息&emsp;&emsp;&emsp;&emsp;&emsp;(2)开启自带的版权声明&emsp;&emsp;&emsp;&emsp;&emsp;(3)自定义文章底部版权声明&emsp;&emsp;&emsp;&emsp;&emsp;其中(1)(3)方法相同，这里我们采用自定义的版权声明方法，关闭自带版权声明。 网站底部统计信息重复。解决办法：同样的，我将自己看的博客中，设置统计信息的方法整理如下：&emsp;&emsp;&emsp;&emsp;&emsp;(1)开启不蒜子博客访问量统计&emsp;&emsp;&emsp;&emsp;&emsp;(2)统计功能,显示文章字数统计,阅读时长,总字数—&gt;这是针对博客正文的&emsp;&emsp;&emsp;&emsp;&emsp;(3)在网站底部加上访问量&emsp;&emsp;&emsp;&emsp;&emsp;(4)网站底部字数统计重复的原因是：同时设置(1)和(3)(4)。把(1)关掉即可。 实现单篇文章阅读次数统计。解决办法：注册leancloud账号，创建新应用，进入新应用，找到AppID和AppKey，填入主题配置文件中。具体过程请参考为NexT主题添加文章阅读量统计功能。]]></content>
      <categories>
        <category>bug汇总</category>
      </categories>
      <tags>
        <tag>next主题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何利用Next主题对博客进行优化]]></title>
    <url>%2F2018%2F06%2F20%2F%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8Next%E4%B8%BB%E9%A2%98%E5%AF%B9%E5%8D%9A%E5%AE%A2%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[博文前言 用Hexo初始化建的网站，其默认的风格比较传统和简陋，不符合我这个当代大学生的气质和要求。所以决定采用应该范围最广泛的Next主题。网上关于这一主题的资料也比较多，需要做些修改也很方便。主要是考虑到这一点。 准备工作 在D:\blog\目录下点击鼠标右键打开Git Bsah,执行命令git clone https://github.com/iissnan/hexo-theme-next themes/next/，将该项目克隆到themes/next/文件夹下。 以下是我在建此博客时，参考的博文和资料。读者可以根据这些资料可以个性化定制自己的博客网站。Hexo-Next-主题优化(一) Hexo-Next-主题优化(二) Hexo-Next-主题优化(三) Hexo-Next-主题优化(四) hexo的next主题个性化教程:打造炫酷网站 Hexo框架+NextT主题搭建博客教程 Next使用中文文档 进入正题 此处内容过于繁杂。我列出我的博客个性化定制的一些内容。 修改默认主题为next。 设置网站的标题，副标题，描述，作者,关键字等。 设置next主题的scheme。 设置侧边栏的菜单项的文本和图标,以及设置点击菜单项时的跳转界面。 鼠标点击出现小心心和爆炸效果。 更改博客的头像，设置头像边框为圆形，以及鼠标点击实现旋转效果。 浏览页面显示当前进度。 设置标签页面，以及设置每篇博客的标签。 设置侧边栏的社交链接和图标。 设置友情链接。 在左上角实现fork me on github。 修改每篇文章底部带#的标签。 添加页面进度加载条。 添加本地搜索。 修改网页底部。 添加统计功能：显示文章字数统计,阅读时长,总字数。 修改文章内的超链接样式。 在每篇文章末尾统一添加结束标志。 开启不蒜子博客访问量统计。 绑定腾讯云域名jinyuxin.club到mrkinghh.github.io。]]></content>
      <categories>
        <category>软件使用</category>
      </categories>
      <tags>
        <tag>next主题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+github建站笔记]]></title>
    <url>%2F2018%2F06%2F20%2FHexo%E5%BB%BA%E7%AB%99%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[博文前言 最近发现同学们都有了自己的技术博客，我也想搞一个自己的博客。于是买了阿里云的服务器和域名，准备大搞一番。结果发现前端对于我来说太痛苦了，真的是一点艺术细胞都没有，网上的模板又不尽如人意，于是不得不选择放弃。最近大家都流行在github上部署自己的个人博客，于是向同学请教了一番,此处特别感谢周住铭。加上在网上搜一搜教程，就开始捣鼓了起来。现将过程记录如下。 准备工作 第一步： 因为Hexo是基于Node.js开发的，所以在使用这个工具之前，我们需要先下载Node.js的环境。点击此处进入Node.js官网,用node -v检查是否安装成功。安装Node.js的过程中，会默认安装npm命令。 第二步： 安装好了Node.js之后，安装git和配置git。点击此处进入git官网，因为从github上克隆Next主题和部署到github的仓库时都需要git。 第三步： 完成前两步之后，接下来在github上注册一个账号，并且新建一个仓库，仓库名为账户名.git.io，这样才能确保可以通过http://账户名.git.io访问你的主页。由于需要部署到github上，因此还需要在本机和github之间建立通信密码，这里我们使用ssh-key的方式。具体操作请参考博客。 第四步： 安装Hexo。先在d盘下新建一个blog的文件夹，进入该文件夹目录。输入命令npm install hexo -g，开始安装Hexo。 安装结束之后，利用命令hexo -v验证是否安装成功。 进入正题 以上全部都是准备工作。利用命令hexo init初始化该文件夹。初始化之后，文件夹结构如下。 利用命令npm install安装所需要的组件。 利用hexo g生静态文件。 利用hexo s启动服务器。 在浏览器中输入localhost://4000查看博客的默认页面。 利用命令npm install hexo-deployer-git --save安装一个扩展，该扩展是用来将本地内容部署到github对应的仓库的。 配置部署的仓库。在bolg文件夹下的_config.yml中，找到deploy项，修改其值如图。。 利用hexo new [post | page | draft] &quot;blog name&quot;新建一篇博客页面。三种选择对应不同的三种方式。其中page对应博客中的非博文页面，主要是点击标签的跳转后的页面，比如404页面，归档页面，分类页面等等。draft代表博文的草稿，执行此命令，则会在D:\blog\source文件目录下生成一个_draft文件夹，用来存放博文草稿。post代表即将发布的博文，放在D:\blog\source\_post目录下。此处我们选择post来直接生成即将发布的博客正文。 利用hexo d将博客部署到github上。 利用http://mrkinghh.github.io访问我的博客主页。]]></content>
      <categories>
        <category>软件使用</category>
      </categories>
      <tags>
        <tag>hexo建站</tag>
      </tags>
  </entry>
</search>
